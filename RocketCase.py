from Engine import Engine
import math
import numpy as np


class RocketCase:
    """
    The RocketCase class is a wrapper class that performed trend analyses given the stage 1 and stage 2 engines, as well as the corresponding inert mass fraction and payload mass.
    """

    def __init__(
        self,
        dVtot: float,
        mPL: float,
        deltas: tuple[float, float],
        engines: tuple[Engine, Engine],
    ):
        """
        :param dVtot: Total Delta-V allocated for the mission
        :type dVtot: float

        :param mPL:   Payload mass allocated for the mission
        :type mPL:   float

        :param deltas: Inert mass fraction for the first and second stage
        :type deltas: Tuple[float,float]

        :param engines: Stage 1 and Stage 2 Engine objects representing the propellant mixtures used.
        :type engines: Tuple[`Engine`,`Engine`]
        """
        self.dVtot = dVtot
        self.mPL = mPL
        self.deltas = deltas
        self.engines = engines

    @property
    def gravity(self):
        """Returns the gravity constant used by operations done inside RocketCase."""
        return 9.81

    def findMasses(self, X):
        """Finds the masses for the first and second stage given a Delta-V fraction split.

        :param X: Percent DeltaV to allocate to the first stage. Second stage allocation is 1-X.
        :type X:  float

        :returns: Mass1 and Mass2, or the stage 1 and stage 2 total, inert, and propellant mass required as dictionaries. The dictionaries can be accesssed with the keys: `m0`,`m_in`,`m_pr`
        :rtype: Tuple[Dict[str, float], Dict[str, float]]
        """
        g = self.gravity
        # ISP1 = self.engines[0].Isp1 #doesnt work
        # ISP2 = self.engines[1].Isp2 #"
        ISP1 = self.engines[0].Isp
        ISP2 = self.engines[1].Isp

        dV1 = self.dVtot * X
        dV2 = self.dVtot * (1 - X)

        # Stage 2 Calcs
        r2 = math.exp(-dV2 / (g * ISP2))
        lambda2 = r2 - self.deltas[1]

        # Mass Calcs Stage 2
        m02 = self.mPL / (r2 - self.deltas[1])
        m_in2 = m02 * self.deltas[1]
        m_pr2 = m02 - self.mPL - m_in2

        Mass2 = {
            "m0": m02,
            "m_in": m_in2,
            "m_pr": m_pr2,
        }  # dict with stage 2 mass values
        # Stage 1 Calcs
        r1 = math.exp(-dV1 / (g * ISP1))

        # Mass Calcs Stage 1
        m01 = m02 / (r1 - self.deltas[0])  # we use m02 at the payload mass for stage 1
        m_in1 = m01 * self.deltas[0]
        m_pr1 = m01 - m02 - m_in1
        Mass1 = {
            "m0": m01,
            "m_in": m_in1,
            "m_pr": m_pr1,
        }  # dict with stage 1 mass values
        return Mass1, Mass2

    def MassTrends(self, X: np.ndarray):
        """Returns the mass trends given a list of Delta-V fractions.

        :param X: List of percents of DeltaV to allocate to the first stage. Second stage allocation is 1-X.
        :type X: np.ndarray

        :returns: X, total masses, and a list of stage 1 and stage 2 masses for a certain Delta-V fraction
        :rtype: Tuple[list[float], list[float], Tuple[list[Dict[str,float]]], list[Dict[str,float]]]
        """

        # Pre-allocate as float array filled with NaN to avoid type warnings
        # Initial mass list, and a list of the dictionaries generated by findMasses
        m0List = np.full(len(X), np.nan, dtype=float)
        S1List = []
        S2List = []

        # Enumerate over all X values given
        for i, xi in enumerate(X):
            m1, m2 = self.findMasses(xi)
            S1List.append(m1)
            S2List.append(m2)

            # Sometimes findMasses generates a negative mass. Guard against illogical values.
            # try:
            m0List[i] = m1["m0"] if m1["m0"] > 0 else np.nan
            # except Exception:
            # m0List[i] = np.nan

        return X, m0List, (S1List, S2List)

    def CostTrends(self, X):
        """Returns the cost trends given a list of Delta-V fractions.

        :param X: List of percents of DeltaV to allocate to the first stage. Second stage allocation is 1-X.
        :type X: list[float]

        :returns: X, total masses, and a list of stage 1 and stage 2 masses for a certain Delta-V fraction
        :rtype: Tuple[list[float], list[Dict[str,list[float]]]]
        """

        # Input: dV Fraction (linear iter)
        # Returns XY array of dV and cost

        # Pre-allocating the costs as float arrays to allow np.nan
        Costs = {
            "S1": np.full(len(X), np.nan, dtype=float),
            "S2": np.full(len(X), np.nan, dtype=float),
            "Total": np.full(len(X), np.nan, dtype=float),
        }

        for i, xi in enumerate(X):
            # Finds Masses then calculats costs -- adding to dictionary
            m1, m2 = self.findMasses(xi)

            s1 = 13.52 * m1["m_in"] ** 0.55
            s2 = 13.52 * m2["m_in"] ** 0.55
            Costs["S1"][i], Costs["S2"][i], Costs["Total"][i] = (
                (np.nan, np.nan, np.nan)
                if m1["m0"] <= 0 or m2["m0"] <= 0
                else (s1, s2, s1 + s2)
            )

        return X, Costs

    @staticmethod
    def findCost(m_in):
        """Uses the cost heuristic to find the mass in millions of dollars.

        :param m_in: inert mass in kg
        :type m_in: float
        """
        return 13.52 * m_in**0.55
